CLASS DESIGN
For example, in Project 2, I used two main classes: Country_Data and Time_Series. Each class is a separate concept in the problem domain and is used to provide a specific set of functionalities. The separation into two classes is a deliberate approach to ensure that the program is scalable, modular, and maintainable. 

The Country_Data class is used to represent a country and its collection of Time_Series objects. The main responsibility of this class is not to manipulate any data point, but to store, organize, add, delete, and query entire time series. On the other hand, the Time_Series class is used to represent a time series. The separation into two classes is a deliberate approach to ensure that the program is scalable, modular, and maintainable. 

In both classes, encapsulation is strictly adhered to. For example, all important data member variables, such as dynamic arrays, capacity, and size variables, including array_size and last_idx, are private. This is a deliberate approach to ensure that these variables cannot be modified from outside the class, which would otherwise result in memory corruption. 

The public interfaces of these two classes are minimal but complete. The methods are only exposed if they are needed by the program’s commands. The helper functions are not supposed to be called from outside the class, like the resizing functions, and are therefore kept as private members.

The most important design decision made in these two classes is the use of dynamic arrays instead of STL’s data structures. The decision is deliberate, as it is an important part of the program’s requirements.

The design decision made in the implementation of the Time_Series class is that all resizing is done by a single function, resizeSeries, which is only called by another function, checkAndResizeSeries. This is the same design decision made in Project 1, where there is exactly one place where resizing of an array is done in the code. The function checkAndResizeSeries is a wrapper function that can be safely called from anywhere before insertions and deletions, as there is only one place where resizing is done.


Similarly, in the Country_Data class, all the resizing of the array of Time_Series objects is performed within the function resizeArray, which is only called by checkAndResizeArray. This prevents duplicated code in the resizing of the array. Another important design choice was the implementation of the deep copy assignment operator for the Time_Series objects. This is because the Time_Series objects are stored in an array, which is dynamically resized in the ADD_P2 and DELETE_P2 operations. If the assignment operator were not implemented, the objects would have shared pointers, leading to double-free issues. Finally, project 2 required some additions compared to Project 1. The main additions were as follows: getter methods to get private variables stored inside of Time_Series (series name, series code, array size, and array capacity) in order to not break the principle of encapsulation for private variables, as well as I also overloaded the assignment operator to allow for straightforward copying of data from one object to another. Finally I included a method that allows program to check if the series has valid data or not, necessary for the mean method, where it must be ascertained early if series does have valid data or nto.

ALTERNATIVES CONSIDERED AND REJECTED

In my development process, I first started with a greater number of helper functions, such as distinct resizing routines for each of the internal arrays. I also explored more general-purpose resizing functions using templates. However, this made my code even more complex and resulted in a greater number of points where the variables related to the size and capacity of the arrays were being altered. This particular design had several issues, such as the duplication of resizing code, which required multiple checks of capacity and modifications to last_idx and array_size in multiple locations. This made my code more prone to errors, more difficult to debug, and resulted in memory bugs that were identified by Valgrind. This was actually really similar to the issues I had in project 1 where I made my code too complicated and that led to many memory errors, and slow debugging (again too many helper funcitons). I finally abandoned this design in favor of a more centralized approach to resizing, with a single routine for each class. This ensured that there was only one source of truth for the resizing and capacity-related operations, making my code less prone to duplication and memory bugs, and also making it more reliable and maintainable.

RUNTIME ANALYSIS

Let N denote the number of time series stored in the Country_Data object, and let m denote the number of data points in a single Time_Series.

DELETE_P2 command worst-case runtime: O(N + m)

DELETE_P2 is implemented by Country_Data::deleteSeries. The method first locates the target series using returnSeriesIdx, which performs a linear scan over the array of N time series. This search takes O(N) time in the worst case.

If the series exists, all subsequent Time_Series objects are shifted left by one position to preserve array contiguity. Each shift invokes the Time_Series copy assignment operator, which performs a deep copy of up to m data points. Since only one series is deleted and the total data copied is bounded by the size of a single series, this contributes O(m) time.

Combining these steps, the worst-case runtime of DELETE_P2 is O(N + m).

ADD_P2 command worst-case runtime: O(N + m)

ADD_P2 implemented by Country_Data::addSeries. Before inserting, the method may resize the country_data array. In the worst case, this requires copying all N existing Time_Series objects, resulting in O(N) time.

The new Time_Series is then loaded using Time_Series::load, which processes m data points, resulting in O(m) time. Finally, assigning the new series into the array calls deep copy assignment operator, which takes O(m) time.

Combine these steps to get a worst-case runtime of O(N + m) for ADD_P2.